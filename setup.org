#+TITLE: Throwaway Agent Lab - Setup & Research
#+AUTHOR: Aidan Pace
#+EMAIL: apace@defrecord.com
#+DATE: 2025-11-23
#+PROPERTY: header-args :mkdirp t
#+STARTUP: overview

* Overview

This repository explores the concept of *throwaway code* for agentic AI systems, based on Armin Ronacher's blog post "Building an Agent That Leverages Throwaway Code" (October 2025).

** Core Concept

Instead of building complex tool systems (like MCP), let AI agents write disposable Python code that executes in a sandboxed environment (Pyodide) to solve problems.

** Key Innovation

#+BEGIN_QUOTE
"Agents are very good at writing code, so why don't we let them write throw-away code to solve problems that are not related to code at all?"
— Armin Ronacher
#+END_QUOTE

* Original Article Summary

** Main Components

1. *Pyodide Runtime* - WebAssembly-based Python interpreter
2. *Virtual File System* - Intercept FS calls for controlled resource access
3. *Durable Execution* - Cache-based checkpointing for long-running tasks
4. *Minimal Tool Set* - Describe, Help, and code execution

** Architecture Pattern

#+BEGIN_SRC mermaid :file docs/architecture.png
graph TD
    A[AI Agent] -->|Generates| B[Throwaway Code]
    B -->|Executes in| C[Pyodide Sandbox]
    C -->|Accesses| D[Virtual FS]
    D -->|Fetches| E[External Resources]
    C -->|Produces| F[Artifacts]
    F -->|Analyzed by| A
    
    G[Durable Execution] -->|Caches| H[Step States]
    H -->|Resumes| A
    
    style C fill:#f9f,stroke:#333,stroke-width:4px
    style D fill:#bbf,stroke:#333,stroke-width:2px
#+END_SRC

* Deep Dive: Related Resources

** Primary References

*** Armin Ronacher's Articles

- [[https://lucumr.pocoo.org/2025/10/17/agent-throwaway-code/][Building an Agent That Leverages Throwaway Code]] (Oct 2025)
- [[https://lucumr.pocoo.org/2025/8/][Replacing MCP with Code]] (Aug 2025)

*** Official Implementations

- [[https://github.com/mitsuhiko/mini-agent][mitsuhiko/mini-agent]] - Reference implementation
- [[https://github.com/anthropics/skills][anthropics/skills]] - Claude Skills repository
- [[https://developers.cloudflare.com/][Cloudflare Code Mode]] - TypeScript MCP bindings

** Foundational Technologies

*** Pyodide Ecosystem

#+BEGIN_SRC mermaid :file docs/pyodide-ecosystem.png
graph LR
    A[Pyodide] --> B[CPython in WASM]
    A --> C[micropip]
    A --> D[Emscripten FS]
    
    C --> E[PyPI Packages]
    D --> F[Virtual Files]
    
    G[Web Worker] --> A
    H[Atomics.wait] --> G
    
    style A fill:#6c6,stroke:#333,stroke-width:3px
#+END_SRC

*Resources:*
- [[https://pyodide.org/][Pyodide Official Site]]
- [[https://emscripten.org/docs/api_reference/Filesystem-API.html][Emscripten Filesystem API]]
- [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics][MDN: Atomics]]

*** Durable Execution Systems

- [[https://temporal.io/][Temporal]] - Workflow orchestration
- [[https://docs.restate.dev/][Restate]] - Durable execution platform
- [[https://durable.co/][Durable]] - Serverless workflows
- [[https://github.com/tembo-io/pgmq][pgmq]] - Postgres message queue

** Academic Context

*** Multi-Agent Systems

- [[https://arxiv.org/abs/2308.08155][AutoGPT]] - Autonomous agents
- [[https://arxiv.org/abs/2303.17760][ReAct]] - Reasoning + Acting paradigm
- [[https://arxiv.org/abs/2305.10601][Voyager]] - Code-writing agent for Minecraft

*** Code Generation Research

- [[https://arxiv.org/abs/2107.03374][Codex]] - Code generation foundations
- [[https://arxiv.org/abs/2203.13474][CodeT]] - Program synthesis with testing
- [[https://arxiv.org/abs/2308.12950][CodeLlama]] - Specialized code models

* Cross-Functional Patterns & Concepts

** 1. Sandbox Security Model

#+BEGIN_SRC mermaid :file docs/security-model.png
graph TB
    A[Untrusted Agent Code] --> B{Sandbox Boundary}
    B -->|✓ Allowed| C[Virtual FS Read]
    B -->|✓ Allowed| D[Computation]
    B -->|✗ Blocked| E[Network Access]
    B -->|✗ Blocked| F[System Calls]
    
    C --> G[Intercepted Fetch]
    G --> H[Validated HTTP]
    H --> I[External API]
    
    style B fill:#f66,stroke:#333,stroke-width:4px
    style G fill:#6cf,stroke:#333,stroke-width:2px
#+END_SRC

*** Related Patterns

- *Capability-based Security* - Grant specific permissions, not broad access
- *Principle of Least Privilege* - Minimal necessary permissions
- *Defense in Depth* - Multiple security layers

*** Comparable Systems

- Docker containers
- Browser same-origin policy
- Java Security Manager
- WebAssembly sandboxing

** 2. Virtual File System Pattern

#+BEGIN_SRC python :tangle src/vfs_concept.py
"""
Conceptual VFS implementation showing interception pattern.
"""

class VirtualFileSystem:
    """Intercept file operations for controlled access."""
    
    def __init__(self):
        self.mounts = {}
        
    def mount(self, path, fetcher):
        """Mount a path to an external fetcher."""
        self.mounts[path] = fetcher
        
    def read(self, path):
        """Read file, potentially from remote source."""
        for mount_path, fetcher in self.mounts.items():
            if path.startswith(mount_path):
                relative = path[len(mount_path):]
                return fetcher(relative)
        raise FileNotFoundError(path)

# Example usage
vfs = VirtualFileSystem()
vfs.mount('/api/', lambda p: fetch_from_api(p))
vfs.mount('/local/', lambda p: read_local_cache(p))
#+END_SRC

*** Related Patterns

- *Virtual File System (VFS)* - Abstraction layer over storage
- *Proxy Pattern* - Indirect access control
- *Lazy Loading* - Fetch only when accessed
- *FUSE (Filesystem in Userspace)* - User-space FS implementation

*** Applications

- Plan 9's file system everything
- /proc in Linux
- Cloud storage mounting (rclone, s3fs)
- WASM filesystem layers

** 3. Durable Execution Pattern

#+BEGIN_SRC python :tangle src/durable_exec.py
"""
Simple durable execution with caching.
"""

def durable_workflow(task_id, initial_state, max_steps=100):
    """
    Execute workflow with checkpoint/resume capability.
    """
    state = initial_state
    
    for step in range(max_steps):
        cache_key = f"{task_id}:step:{step}"
        
        # Try to resume from cache
        cached = load_from_cache(cache_key)
        if cached:
            state = cached['state']
            print(f"Resumed from step {step}")
            continue
            
        # Execute step
        state = execute_step(state, step)
        
        # Cache result
        save_to_cache(cache_key, {'state': state, 'step': step})
        
        if is_complete(state):
            break
            
    return state

def load_from_cache(key):
    """Load cached state (Redis, Postgres, etc.)"""
    pass

def save_to_cache(key, data):
    """Save state to cache"""
    pass

def execute_step(state, step):
    """Execute one step of the workflow"""
    pass

def is_complete(state):
    """Check if workflow is complete"""
    pass
#+END_SRC

*** Related Patterns

- *Saga Pattern* - Distributed transactions with compensation
- *Event Sourcing* - Rebuild state from events
- *Checkpoint/Restart* - Save and resume computation
- *Idempotency* - Safe to retry operations

*** Systems Using This

- Temporal workflows
- AWS Step Functions
- Apache Airflow (with XCom)
- Dask distributed computing

** 4. Code as Configuration Pattern

#+BEGIN_SRC mermaid :file docs/code-as-config.png
graph LR
    A[Declarative Config] -->|Limited| B[Fixed Tools]
    C[Code Generation] -->|Unlimited| D[Dynamic Tools]
    
    E[YAML/JSON] --> A
    F[Python/JS] --> C
    
    B --> G[Tool 1]
    B --> H[Tool 2]
    B --> I[Tool 3]
    
    D --> J[Generated Tool N]
    D --> K[Composed Workflows]
    
    style C fill:#6c6,stroke:#333,stroke-width:3px
    style D fill:#6f6,stroke:#333,stroke-width:2px
#+END_SRC

*** Philosophy

- *Infrastructure as Code* (Terraform, Pulumi)
- *Configuration as Code* (Jsonnet, Dhall)
- *Tools as Code* (This approach!)

*** Trade-offs

| Approach | Flexibility | Safety | Complexity |
|----------|-------------|--------|------------|
| Static Tools | Low | High | Low |
| DSL/Config | Medium | Medium | Medium |
| Code Generation | High | Low | High |

** 5. Async-to-Sync Bridging

The ~Atomics.wait~ pattern for making async operations appear synchronous:

#+BEGIN_SRC javascript :tangle src/async_bridge.js
// Main thread - blocks until worker completes
function syncFetch(url) {
  const buffer = new SharedArrayBuffer(4);
  const signal = new Int32Array(buffer);
  const { port1, port2 } = new MessageChannel();
  
  worker.postMessage({ url, buffer, port: port2 }, [port2]);
  
  Atomics.wait(signal, 0, 0);  // Block!
  
  const result = receiveMessageOnPort(port1);
  port1.close();
  
  if (result.message.error) throw result.message.error;
  return result.message.data;
}

// Worker thread - performs async operation
onmessage = async ({ url, buffer, port }) => {
  const signal = new Int32Array(buffer);
  try {
    const data = await fetch(url).then(r => r.arrayBuffer());
    port.postMessage({ data: new Uint8Array(data) });
    Atomics.store(signal, 0, 1);
  } catch (error) {
    port.postMessage({ error });
    Atomics.store(signal, 0, -1);
  } finally {
    Atomics.notify(signal, 0);  // Wake main thread
    port.close();
  }
};
#+END_SRC

*** Related Patterns

- *Fiber/Coroutine* - Cooperative multitasking
- *Green Threads* - User-space threading
- *Continuation* - Suspended computation
- *Future/Promise* - Async result containers

*** Similar Systems

- Python's ~asyncio.run()~
- Rust's async/await
- JavaScript Promise unwrapping
- Go's goroutines

* Implementation Roadmap

** Phase 1: Basic Sandbox

#+BEGIN_SRC org :tangle TODO.org
* TODO Set up Pyodide runtime in Node.js
* TODO Implement basic code execution
* TODO Add simple file system interception
* TODO Create example agent loop
#+END_SRC

** Phase 2: Advanced Features

#+BEGIN_SRC org :tangle TODO.org
* TODO Implement durable execution with Redis
* TODO Add async-to-sync FS operations
* TODO Create "Describe" tool for image analysis
* TODO Build "Help" tool with RAG
#+END_SRC

** Phase 3: Production Hardening

#+BEGIN_SRC org :tangle TODO.org
* TODO Add resource limits (CPU, memory, time)
* TODO Implement proper error recovery
* TODO Create monitoring and observability
* TODO Write comprehensive tests
#+END_SRC

* Project Structure

#+BEGIN_SRC bash :tangle setup.sh :shebang #!/bin/bash
# Create project structure

mkdir -p {src,tests,docs,examples,notebooks}
mkdir -p src/{agent,sandbox,tools,utils}
mkdir -p tests/{unit,integration}

# Create placeholder files
touch src/agent/{loop.py,planner.py,executor.py}
touch src/sandbox/{pyodide_runtime.py,vfs.py,security.py}
touch src/tools/{describe.py,help.py,base.py}
touch src/utils/{cache.py,logging.py}

echo "Project structure created!"
#+END_SRC

** Proposed Directory Layout

#+BEGIN_EXAMPLE
throwaway-agent-lab/
├── setup.org              # This file
├── README.md              # Generated from org
├── pyproject.toml         # Python dependencies
├── package.json           # Node dependencies (Pyodide)
├── src/
│   ├── agent/            # Agent loop & planning
│   ├── sandbox/          # Pyodide runtime & VFS
│   ├── tools/            # Built-in tools (Describe, Help)
│   └── utils/            # Caching, logging, etc.
├── tests/
│   ├── unit/
│   └── integration/
├── examples/             # Example agents
├── notebooks/            # Jupyter experiments
└── docs/                 # Generated diagrams & docs
#+END_EXAMPLE

* Dependencies

** Python (Agent Side)

#+BEGIN_SRC toml :tangle pyproject.toml
[project]
name = "throwaway-agent-lab"
version = "0.1.0"
description = "Exploring throwaway code for AI agents"
authors = [{name = "Aidan Pace", email = "apace@defrecord.com"}]
requires-python = ">=3.11"
dependencies = [
    "anthropic>=0.40.0",
    "openai>=1.0.0",
    "redis>=5.0.0",
    "pydantic>=2.0.0",
    "rich>=13.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "pytest-asyncio>=0.21.0",
    "black>=23.0.0",
    "ruff>=0.1.0",
    "mypy>=1.0.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
#+END_SRC

** Node.js (Sandbox Side)

#+BEGIN_SRC json :tangle package.json
{
  "name": "throwaway-agent-lab",
  "version": "0.1.0",
  "type": "module",
  "dependencies": {
    "pyodide": "^0.26.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  }
}
#+END_SRC

* Mermaid Diagrams

** Agent Execution Flow

#+BEGIN_SRC mermaid :file docs/execution-flow.png
sequenceDiagram
    participant User
    participant Agent
    participant CodeGen
    participant Sandbox
    participant VFS
    participant Cache
    
    User->>Agent: Submit task
    Agent->>Cache: Check for cached progress
    
    loop Until complete or max steps
        Agent->>CodeGen: Generate next step code
        CodeGen->>Sandbox: Execute in Pyodide
        Sandbox->>VFS: Access resources
        VFS->>VFS: Intercept & fetch
        VFS-->>Sandbox: Return data
        Sandbox-->>Agent: Execution result
        Agent->>Cache: Save checkpoint
        
        alt Needs analysis
            Agent->>Agent: Use Describe tool
        end
        
        alt Needs help
            Agent->>Agent: Use Help tool
        end
    end
    
    Agent-->>User: Final result
#+END_SRC

** Tool Architecture

#+BEGIN_SRC mermaid :file docs/tool-architecture.png
classDiagram
    class Tool {
        <<abstract>>
        +name: str
        +description: str
        +execute(context) Result
    }
    
    class CodeTool {
        +sandbox: PyodideSandbox
        +execute(code) Result
    }
    
    class DescribeTool {
        +model: VisionModel
        +execute(file_path) Description
    }
    
    class HelpTool {
        +rag_system: RAG
        +execute(query) HelpText
    }
    
    class ToolRegistry {
        +tools: Dict~str, Tool~
        +register(tool)
        +get(name) Tool
    }
    
    Tool <|-- CodeTool
    Tool <|-- DescribeTool
    Tool <|-- HelpTool
    ToolRegistry o-- Tool
#+END_SRC

** Comparison: Traditional vs Throwaway Code

#+BEGIN_SRC mermaid :file docs/comparison.png
graph TB
    subgraph Traditional["Traditional Tool Approach"]
        A1[Agent] --> B1[Tool Registry]
        B1 --> C1[Tool 1: PDF Reader]
        B1 --> D1[Tool 2: Image Gen]
        B1 --> E1[Tool 3: Calculator]
        B1 --> F1[Tool N...]
        
        G1[Need New Tool?] --> H1[Developer Implements]
        H1 --> I1[Deploy & Update]
    end
    
    subgraph Throwaway["Throwaway Code Approach"]
        A2[Agent] --> B2[Code Generator]
        B2 --> C2[Sandbox]
        C2 --> D2[Python Ecosystem]
        D2 --> E2[Any PyPI Package!]
        
        G2[Need New Tool?] --> H2[Agent Writes Code]
        H2 --> C2
    end
    
    style Traditional fill:#fcc,stroke:#333
    style Throwaway fill:#cfc,stroke:#333
#+END_SRC

* Key Insights & Design Principles

** Why This Works

1. *LLMs are excellent at code generation* - Much better than at using APIs
2. *Python ecosystem is mature* - Thousands of well-documented packages
3. *Sandboxing is now practical* - WASM makes safe execution easy
4. *File systems are universal* - Every developer understands them

** Design Principles

*** 1. Simplicity Over Complexity

#+BEGIN_QUOTE
"What is a little bit disappointing is that there is no truly simple durable execution system."
#+END_QUOTE

Build the simplest thing that works. Don't over-engineer.

*** 2. Safety Through Isolation

- No network access from sandbox
- All external I/O through file system
- Time and resource limits
- Interruptible execution

*** 3. Composability

- Tools can be combined naturally through code
- File system enables data flow between steps
- Durable execution enables long-running workflows

*** 4. Developer Experience

- Agents use familiar abstractions (files, Python)
- Easy to debug (just read the generated code)
- Natural error messages

* Research Questions

** Open Problems

1. *How to balance safety and capability?*
   - More PyPI packages = more power, more risk
   - Which packages should be allowed?

2. *How to handle long-running tasks?*
   - Durable execution is essential but complex
   - What's the simplest viable approach?

3. *How to validate generated code?*
   - Static analysis?
   - Runtime monitoring?
   - Both?

4. *How to handle non-determinism?*
   - LLM output varies
   - How to ensure reproducibility?

** Experiments to Run

#+BEGIN_SRC org :tangle EXPERIMENTS.org
* EXPERIMENT Compare durable execution approaches
:PROPERTIES:
:EFFORT: 8h
:END:
Test Temporal, Restate, and simple Redis-based caching.
Measure complexity, performance, reliability.

* EXPERIMENT Evaluate PyPI package safety
:PROPERTIES:
:EFFORT: 4h
:END:
Create whitelist of safe packages.
Test security boundaries with dangerous operations.

* EXPERIMENT Benchmark agent performance
:PROPERTIES:
:EFFORT: 6h
:END:
Compare traditional tools vs throwaway code.
Measure success rate, execution time, resource usage.

* EXPERIMENT Test VFS interception patterns
:PROPERTIES:
:EFFORT: 4h
:END:
Implement different FS architectures.
Evaluate ease of use and security.
#+END_SRC

* References & Further Reading

** Papers

- [[https://arxiv.org/abs/2303.17760][ReAct: Synergizing Reasoning and Acting in Language Models]]
- [[https://arxiv.org/abs/2210.03629][PAL: Program-aided Language Models]]
- [[https://arxiv.org/abs/2308.08155][A Survey on Large Language Model based Autonomous Agents]]

** Tools & Frameworks

- [[https://github.com/Significant-Gravitas/AutoGPT][AutoGPT]] - Autonomous agent framework
- [[https://github.com/langchain-ai/langchain][LangChain]] - Agent orchestration
- [[https://github.com/reworkd/AgentGPT][AgentGPT]] - Web-based autonomous agent

** Related Blogs

- [[https://www.anthropic.com/research][Anthropic Research Blog]]
- [[https://blog.cloudflare.com/][Cloudflare Blog]]
- [[https://simonwillison.net/][Simon Willison's Blog]] - Excellent AI coverage

* Metadata

#+BEGIN_SRC yaml :tangle .metadata.yaml
project:
  name: Throwaway Agent Lab
  version: 0.1.0
  status: experimental
  
technologies:
  runtime: pyodide
  languages: [python, javascript, typescript]
  tools: [anthropic, openai, redis]
  
concepts:
  - throwaway code
  - agentic ai
  - sandboxed execution
  - durable workflows
  - virtual file systems
  
inspired_by:
  - author: Armin Ronacher
    url: https://lucumr.pocoo.org/2025/10/17/agent-throwaway-code/
#+END_SRC

* License

#+BEGIN_EXAMPLE
MIT License

Copyright (c) 2025 Aidan Pace

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
#+END_EXAMPLE
